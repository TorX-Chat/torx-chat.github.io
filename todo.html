<!DOCTYPE html>
<html>
<head>
	<title>TorX | Project-Wide Unified TODO List</title>
	<link rel='shortcut icon' href='https://raw.githubusercontent.com/TorX-Chat/torx-gtk4/main/other/icon_round.ico'/>
	<style>
		a:link, a:visited {
			color: #add8e6;
		}
		body {
			margin: 0;
			padding: 0;
			height: 200%; /* to make sure there's enough content to scroll */
			background-color: #181a1b;
			color: white;
		}
		nav {
			position: fixed;
			width: 100%;
			background-color: #333;
			color: white;
			padding: 5px 0;
			text-align: center;
			z-index: 1000; /* ensures the nav stays on top of other content */
		}
		section {
			margin-left: 5px;
			padding-top: 30px; /* extra space to ensure content is not hidden behind the fixed nav */
		}
	</style>
</head>
<body>
	<nav>
		<a href="index.html">Home</a>
		<a href="#schedule">Schedule</a>
		<a href="#library">Library</a>
		<a href="#ui">UI</a>
		<a href="#gtk4">GTK4</a>
		<a href="#flutter">Flutter</a>
	</nav>
	<section id="schedule">
		<h1>Project-Wide Unified TODO List / Schedule</h1>
		<img alt="Logo" width="256" height="256" src="https://raw.githubusercontent.com/TorX-Chat/torx-gtk4/main/other/scalable/apps/logo-torx-symbolic.svg" align="right" style="position: relative; top: 0; left: 0;">
		<h3>Schedule</h3>
		<h4>Minimal project-wide goals before full-release:</h4>
		<ul>
			<li>Proper documentation of base protocols / handshake</li>
			<li>Doxygen compatible documentation (?) at least for UI exposed library functions</li>
			<li>MacOS build</li>
		</ul>	
		<h4>Ideal project-wide goals before full-release:</h4>
		<ul>
			<li>Ncurses client</li>
			<li>CLI/API client for integration with AI bots/etc (Julia)</li>
			<li>Google PlayStore listing</li>
			<li>FDroid listing (official repo, not ours)</li>
			<li>Packaging for most major Linux/BSD distributions (official or otherwise)</li>
			<li>iOS support</li>
		</ul>
		<h4>For public discussion (Library):</h4>
		<ul>
			<li>Peer struct is currently an array of struct; there may be benefits to moving it to a linked list, facilitating more of an OOP approach, though an incredible amount work would be involved.</li>
			<li>Putting in a "wrong" password could be made impossible. We could accept any password and just create a new config file. When unlocking, we could try the hashed password (decryption_key) against all config files.</li>
			<li>Git submodules vs ExternalProjects_Add vs other?</li>
			<li>Seperate "keys" and "settings" databases? Currently a bad setting can crash the application (such as a bunk sticker). UI developers should work to prevent this, rather than working around the problem in a brutal fashion such as by encouraging users to delete their settings database. (which would be very hard on mobile). If implementing, remember to implement in change_password.</li>
			<li>Use timezone info to determine default torrc? (Briar does this. This could really be a UI thing, though we do have the censored_region variable in lib). Timezone + language would be more effective.</li>
			<li>File transfers: fallocate(linux)/lseek(linux) or pre-allocate files in some sort of null state. Would have to do this in OS specific manners https://devblogs.microsoft.com/oldnewthing/20160714-00/?p=93875</li>
			<li>Could allow protocols to require an acknowledgement (ACK) of receipt by sending a fnv1a unsalted hash (uint32) back. Using a 64 byte checksum is unnecessary and wastes RAM space in the message struc, HOWEVER a truncated SHA3 may be better because it would be able to handle larger message sizes, because it doesn't rely on loading the entire message into stack... but we could easily re-write the fnv1a hasher function to use the heap. Either method does not require both sides to keep a shared index number of any type. Would need to store hashes for sent messages of this type in struct so that confirmation could rapidly be determined without having to re-hash every such message. Alternatively, we could just use time:nstime or time:nstime + hash.</li>
		<!--	<li>M****o-cli integration (not before full release / 2025)</li>
			<ul>
				<li>Might be difficult to implement for mobile if unsafe shutdowns of M****o cause b********n indexing corruption. However M****o-cli offers remote b********n options that would probably be safe from unsafe shutdowns.</li>
				<li>Can reptyr steal control of a CLI program running in fork? (presuming no, but can other methods?) If so then we need to integrate M****o by function calls rather than CLI. Should talk to devs or look at existing implementations.</li>
			</ul> -->
		</ul>
		<h4>For public discussion (UI Clients):</h4>
		<ul>
			<li>Be able to drag messages / completed files to other peers? Accidents could occur. Another option is "Forward to".</li>
			<li>Keyboard Privacy in Flutter being enabled by default: it breaks non-alphabetical languages such as Chinese</li>
		</ul>
	<section id="library">
		<h3>TODO List for TorX Library:</h3>
		<h4>High Priority / Security Audit:</h4>
		<ul>
		<!--	<li>event_strc->buffer, event_strc->buffer_len, event_strc->untrusted_message_len, should PROBABLY be per fd_type? NO. sockfd is only one, authenticated is only one. We have one event_strc per half-duplex connection</li> -->
		<!--	<li>We do htobe stupidly, everywhere in C. Should do it as *(uint32_t *)&message[4] = htobe32(1234); (must cast when >1 byte). NOTE: CHATGPT SAYS THIS IS UNWORKABLE DUE TO ALIGNMENT.</li> -->
			<li>Rewrite anywhere that we pass n+i to pass n+struct instead. Array of struct works fine for everything except messages.</li>
			<ul>
				<li>Messages should be a linked list, then there is no realloc being called when loading and deleting messages, making deletion of stream messages low-cost.</li>
				<li>UI message will have to register its' location with a void pointer to the library message, and library message will have to have a callback trigger to tell UI to delete the UI message before deleting itself.</li>
				<li>Printing messages by linked list should be possible because we already do it in groups.</li>
				<li>To consider: use reference counter on group stream messages and delete when too old or all sent.</li>
			</ul>
			<li>Every library function should do basic sanity checks (ex: n > -1 && n < threadsafe_read_int(&mutex_global_variable,&max_peer), g > -1 && g < threadsafe_read_int(&mutex_global_variable,&max_group), etc), either with -1 or 0 error level, as appropriate. Diagnosing a -1 shutdown is far easier than a segfault on Android.</li>
			<li>ENUM_PROTOCOL_FILE_INFO_REQUEST maybe should not be facilitated in public groups.</li>
			<li>Certain types of group streams (A/V call data, for example) need only be sent to a subset of group peers.</li>
			<li>Pointer objects are not properly accessible through getter_array and will fail getter_array_sanity_check and getter_group_array_sanity_check, with the exception of message. We will need to implement null checks and strlen.</li>
			<li>offer/request_list is not accessible through getter/setter functions. If we don't rapidly remedy this, we will inconvenience future UI devs.</li>
			<li>Some file related protocols are saved even if logging is disabled. This should be resolved.</li>
			<li>message_resend hasn't been tested in a while. Test with public groups, private groups(signed), p2p.</li>
			<li>Restarting Tor calls sql_populate_peer again. Much of it may be unnecessary if(messages_loaded). load_onion(n) and peer_init or whatever does tor calls may be necessary. More importantly, we should probably find a way to take down onions before shutting down Tor. If we did that, we could eliminate issues.</li>
			<li>GROUP_OFFER_ACCEPT: ONLY respond IF we verify that we already sent this peer an UNUSED invitation (perhaps we should save this with extraneous), otherwise could be issues (ie, a malicious peer could accept multiple times and bring in a bunch of people)</li>
			<li>iOS (Orbot) / System Tor: We need to re-write tor_call so that all calls are on a single connection and ADD_ONION does not utilize "Detached". See Tor's control-spec.txt. That will enable us to run safely without control_password. However it will not achieve Orbot compatibility at least on Android (which starts up with a random CTRL_PORT). We could work with their devs to get them to resolve the issue.</li>
			<li>Tor not dying keeps onions online after crash. Consider the viability of a Tor Killer process that will kill Tor if TorX's PID dies. It could just be a wait() kill() process, being forked from TorX with possession of both Tor and TorX PIDs. This would be useful to ensure that Tor and its hidden services aren't left hanging if TorX crashes or is improperly closed. NOTE: probably better to use just not use detached? Next startup would kill tor via PID.</li>
			<li>Consider the viability of (or move towards) full-duplex messages of all types, and treating files nearly the same as any other message.</li>
			<ul>
				<li>Every message would need to have a checksum (for matching) and a start point, similar to how we do files now.</li>
			</ul>
			<li>File transfer checksums fail after combination of sender crashes, stickers, messages, multi-file transfers, etc. Need audit.</li>
			<li>Callback for invalid or incomplete message (which could be illict attempts to ping or do traffic analysis).</li>
			<ul>
				<li>Minor notice for incomplete, major for invalid + counter.</li>
				<li>Warning: After a file is cancelled, a peer can keep sending data or re-start sending data and we receive/disgard it. This could be exploited to monitor a peer.</li>
				<li>Need to somehow notify a peer that such packets are still inbound.</li>
				<li>Issue: Incomplete messages come in frequently in normal operation (faster than a monitor's framerate)</li>
				<li>Issue: Invalid messages could come *incredibly* infrequently, if a malicious peer (ie, a peer could report a 1000 GB message and send it over weeks, never triggering an 'invalid' warning).</li>
				<li>Thought: Invalid messages already report errors, so do we *really* need redundant callback, which has very little legitimate value?</li>
			</ul>
			<li>Arti / Vanguards</li>
			<ul>
				<li>Need to migrate to Arti as soon as viable and enable full vanguard support https://spec.torproject.org/vanguards-spec/full-vanguards.html</li>
				<li>Background: https://blog.torproject.org/tor-is-still-safe/index.html https://blog.torproject.org/announcing-vanguards-for-arti/</li>
				<li>Alternative mitigation method offering full-vanguards (Note: abandonware) https://github.com/mikeperry-tor/vanguards</li>
				<li>Tor >= 0.4.7.0 already has built-in support for Vanguards-lite: https://spec.torproject.org/vanguards-spec/vanguards-lite.html</li>
			</ul>
			<li>Need a red team building malicious or buggy client/library, which will send undersized/oversized messages, spam attacks, etc.</li>
		</ul>
		<h4>Medium Priority:</h4>
		<ul>
			<li>(Easy fix) In sql_populate_message, if(reverse) and if(protocol == ENUM_PROTOCOL_FILE_REQUEST), we should probably avoid "status = " changes to _ACCEPTED.</li>
			<li>(Easy fix) Implement a "min_fail" to reduce the cost of begin_cascade and peer_offline. It should initialize at 0, be increased to max_i by begin_cascade, and be reduced to min_i by load_more. It should only be utilized by begin_cascade and perhaps peer_offline. Alternative: pass i of last sent message to begin_cascade, but that won't account for load_more, which may or may not be desirable. Simpler though. NO ---> Implement an `int* queue` in peer struct. Add 'i' to it when "Refusing to send_prep" and "Send_prep too early" in send_prep, and when `].stat = ` in load_messages_struc. Read from queue to determine next message to send, in begin_cascade. Remove from queue in packet_removal and when message is deleted (Note: may not be necessary when deleted). Note: This is 'low priority' because show_log_messages limits the amount of messages required to be parsed without a queue. NOTE: Could result in rare double-sends due to race between begin_cascade and packet_removal? Our current setup is subject to the same potential race? Presumably yes on socket_swappable messages, since ENUM_MESSAGE_SENT is set in packet_removal. Both sockets *could* hypothetically send the same message. Solution is to "claim" it somehow? Minor problem, solve later as seperate TODO.</li>
			<li>2025/04/13 Flutter: "Cannot open file path /data/user/0/com.torx.chat/cache/file_picker/1744539315957/新建文本文档 (2).txt for sending. Check permissions.". Caused by a file being shared from "Recent", then (an hour or two later) accepted by peer. Temporary solution (and good idea): Peer will naturally re-send file with same hash after this bug. When receiving a file offer for a file we already have and have already made a request for (presumably which is stalled), re-request it.</li>
			<li>ENUM_PROTOCOL_FILE_REQUEST is logged so that we can set the status of the file. This is a lot of bloat, considering that one file could have many requests, especially in groups. It would be more efficient (disk space) to store the file status in another manner.</li>
		<!--	<li>If messages are ENUM_STREAM_DISCARDABLE and logged, we could have them save only after sending (ex: File Request). Note: Doesn't STREAM imply it is deleted after sending? We might need another type... </li> -->
			<li>Group file transfers of 4 byte files fail in file_init: "Coding or IO error. File size != sum of sections" 4!=8. More testing and diagnosis required.</li>
			<li>"Last transferred > transferred" occurs frequently (on the sender side only?) when starting file transfers.</li>
			<li>Blacklisting should only occur if you requested the whole section from a single peer, otherwise we have no idea who we got the bad packet from. We currently have no way of tracking this because we only track split_status_req. We will have to track split_status_req_start and split_status_req_end.</li>
			<li>Zero_ functions should have UI callbacks. There are limitations related to locks regarding how we could implement this. Remember to put them outside the function (after is preferable, but before is fine during shutdown).</li>
			<li>Group File Transfers:</li>
			<ul>
				<li>Important: select_peer should probably return a list of peers, or at least a fd_type and the proposed section.</li>
				<li>select_peer seems to select the original offerer of a file most of the time, rather than utilizing those who sent FILE_OFFER_PARTIAL data.</li>
				<li>We rely on section_update to request the next section when one section is complete, but what if we requested less than a full section from a peer? ie: if we requested from a _PARTIAL? Until we resolve this, we should perhaps avoid requesting partial sections.</li>
			<!--	<li>If select_peer selects a peer who sent FILE_OFFER_PARTIAL data, "File request too early", meaning .bev_recv is null, which means the n may be wrong?</li>
				<li>"packet_removal reported message pos > message_len" occurs during transfer. Despite all efforts, we don't know why.</li>	-->
				<li>Need a ENUM_PROTOCOL_FILE_REFUSE protocol so that, for example, if a peer has moved/deleted a file or changed its permissions, the requesting peer doesn't wait endlessly for data to arrive after making a request. Note: Can simply send a _PARTIAL with 0/0/0 and have the receiver cancel any requests from this peer.</li>
			</ul>
			<li>CMakeLists.txt:</li>
			<ul>
				<li>Needs to have install directive (LIBRARY DESTINATION lib), to allow independent builds and installs of .so file, without re-compiling UIs.</li>
				<li>set(SSL_ARCH linux-x86_64) is hardcoded, except on android. will be issues on *pi, postmarketOS, macbooks, etc.</li>
				<li>CMakeLists.txt files can be ran through AI. Add debug messages with message(STATUS hello) and run with cmake --trace for debugging.</li>
			</ul>
			<li>Prioritize our own broadcasts: Calling broadcast_add(-1,...), to add a group, could take a very long time because manually added groups are not prioritized in broadcast_threaded. Should probably have an additional queue of high priority (our own) broadcasts.</li>
			<li>Due to message_prep existing within message_send, and only one g being passed around (no distinction between "relevant g" and "target g"), it's impossible to send a group offer into a group.</li>
			<li>Search (again) for ]; and ] = { then ensure zero'd.</li>
			<li>Streaming a group message is going to be a message struct bloat issue because, unlike other stream messages, upon outbound send it is not deleted from group_ctrl (the group_ctrl n,i is not zero_i'd). The solution is to somehow track when all the attempts are done (perhaps in message_send) and then zero_i it (see: sfaoij2309fjfw). We may also need to have a time-deletion where after a certain number of seconds we just consider it no longer relevant.</li>
			<li>Multi-Device / Blinded keys. Use the nonce method to generate blinded keys. Do it using onion_gen.c Upload it using HSPOST. See src/feature/hs/hs_common.c for creation of blinded keys. See any mentions of "blind" "period" "time" in the src. I think HSPOST is somehow combined with ADD_ONION to publish? Unsure and will need to ask #tor-dev</li>
			<li>GROUP FILE TRANSFER Documentation: Outbound uses peer_n fd for disk reads, Inbound uses group_ctrl fd for disk writes. When receiving file request, it appears we store outbound date in the group_peer_n. This needs to be documented/understood. When changing file status in process_pause_cancel, we might need to iterate through the relevant group_peer_n and set their status too? idk if we store status there or only transfer amount.</li>
			<li>We can't support uint64_t file sizes because ftell/fseek only support long int. Unsure what to do about this. It affects our file transfer protocols.</li>
			<li>accept_automatically. Can either be a toggle or a size slider. size_t is probably most logical. Could also have a list of accepted filetypes. NOTE: Enabling this option will require a check for download_dir. Also, this option should could be DANGEROUS for insecure platforms like Windows/OSX/iOS/Android, where CSAM scanning exists.</li>
			<li>If a split_folder exists, files inside should be labelled via truncated checksum rather than filename.</li>
			<li>file_set_path should be able to move a file, if existing and destination is writable.</li>
			<li>Hash is written to disk in plaintext for our .split file. Perhaps we should encrypt (no) or salt + rehash it (not all hashes, just this hash written to .split file). The reason we don't is because the file itself is written next to it, so what is the security in having the hash salted? We do attempt to securely delete .split files.</li>
		<!--	<li>(May be outdated) Requesting a 1 byte file in full-duplex causes an integer overflow / request of a 18446744073709551615 byte file, causing offerer to crash.</li>	-->
			<li>Sodium memory management overhead: Check for compile-time flags that could disable the wasted pages except on debug builds. sodium_malloc() wastes too much memory by allocating 4kb of space for each malloc. See <a href="https://github.com/jedisct1/libsodium/blob/master/src/libsodium/sodium/utils.c">HAVE_PAGE_PROTECTION</a></li>
			<li>Clean up error messages / notices / checkpoints using macro defined levels to determine whether debug level + whether they contain sensitive info.</li>
			<li>Error messages cannot be inside torx_read/torx_write in case callbacks are guaranteed to be handled asyncronously, by adding them to a queue. Currently, very few are, if any.</li>
			<li>2025/04/29: After dozens or hundreds of disconnections occuring rapidly, we get "ERROR MEMORY sqlcipher_mlock: mlock() returned -1 errno=12". This is possibly from too many sodium_malloc not being free'd when disconnecting?</li>
		</ul>
		<h4>Low Priority:</h4>
		<ul>
			<li>A "getter_exists" function could exist, which would at minimum be used for pointers to see if they are NULL. Could error out if not a pointer, or do some other form of checks like a zero check on the first byte (for onions, peeronions) or is_null (for hashes, other arrays).</li>
			<li>Change 'n' to 'file_n' in file related functions that are passed n,f pairs or n,f,peer_n. n and file_n must NEVER be used together in a function, to prevent confusion/mistakes. Relevant variable names: file_n, target_n, group_n, peer_n, etc.</li>
			<li>If messages.db is deleted or message history is deleted, _ENTRY_REQUEST _FAIL messages will be deleted, which means public groups we are trying to join will never be joined.</li>
			<li>2025/01/15: Pausing is near indistinguishable from simply being inactive (ENUM_FILE_INACTIVE_ACCEPTED). As long as file_path is set, we treat it as accepted, and then any incoming offer will start the transfer. This inability to permanently pause (without cancelling) is annoying, but we never had a strong pause because either peer could unpause. Therefore, this is OK. Do not abolish pause protocol. It serves other purposes.</li>
			<li>We have some places where we unnecessarily fwrite multiple times in sequence rather than once, such as in initialize_split_info.</li>
			<li>Investigate changing build system to Meson and using Git submodules, as suggested in Issue #2.</li>
			<li>Don't send a ENUM_PROTOCOL_FILE_OFFER_PARTIAL to the peer we received the data from. (Actually, maybe this shouldn't be done).</li>
			<li>PROPOSE_UPGRADE:</li>
			<ul>
				<li>After acting on a PROPOSE_UPGRADE, a restart is required before v3auth will be implemented. This can be resolved.</li>
				<li>Currently we PROPOSE_UPGRADE on every connection. We can avoid that if we store the current value of the connection and not just peerversion.</li>
			</ul>
			<li>There are a few places we can be more careful about not de-referencing null pointers. Search blake3.c and base32.c for "	*" (aka \t*). The blake3 functions do no sanity checks on arguments passed, and the base32_decode function can be to be re-written (in stack).</li>
			<li>"Include the system error text (from perror or equivalent) in every error message resulting from a failing system call" https://www.gnu.org/prep/standards/html_node/Semantics.html</li>
			<li>Onloading/offloading old messages:</li>
			<ul>
				<li>Offloading: Should leave us with just -10 to 10 initialized, on all peers</li>
				<ul>
					<li>delete_log should probably be broken up into log_delete and shrink_message_struct, where log_delete calls shrink_message_struct, but shrink_message_struct can be separately called. Both could take n (or -1) as args.</li>
				</ul>
				<li>Cache Solution Proposal #1 (bad)</li>
				<ul>
					<li>When offloaded, we cache on the initialized message struct, then when re-loading, we just move to a temp local pointer, then sql_populate_message, then add back the cached messages via load_message_struc</li>
				</ul>
				<li>Cache Solution Proposal #2 (better)</li>
				<ul>
					<li>We offload all messages, except the 10 most recent, which we move to 0 to 10.</li>
					<li>If we keep the ~50 most recent instead of 10, we can just rely on load_more later.</li>
				</ul>
				<li>Remaining issue: We can't just offload all except a set number because then group_peer messages won't align with the appropriate group_n messages.</li>
			</ul>
			<li>Add a `message_spoof(n,time,nstime,data,len)` function where users can click between messages to add a fake message to their history. Primary Issue: How we fit this into the message struct? This is where a linked list struct would be handy. Secondary issue: Is there significant value? The order in which it is inserted into SQLCipher might give it away as non-genuine.</li>
			<li>Multiple offers of the same file with different filenames to the same peer has some weird behavior but is safe.</li>
			<li>Documentation: As of 2.0.10, PIPE_AUTH is signed and utilized when v3auth is not available (Tor <0.4.6.1) to facilitate secure full-duplex connections.</li>
			<li>Documentation: PROPOSE_UPGRADE works for upgrades from v1 (PIPE_AUTH) to v2 (v3auth), but cannot facilitate downgrades (and for many reasons should/will never). However, if both peers upgrade then disable v3auth, it will successfully fall back to PIPE_AUTH.</li>
			<li>Where multiple getter functions occur in a block, it would be more efficient to manually lock/unlock once.</li>
			<li>Consider implementation of Proof of Work https://spec.torproject.org/hspow-spec/v1-equix.html for multiple use IDs, when sufficiently mature</li>
			<li>Convert or eliminate remaining ~100 printf to error_printf</li>
			<li>Takedown_onion must call disconnect_forever in a threadsafe manner. We've tried everything (evbuffer_lock, event_base_once, etc) and can't find a way.</li>
			<li>file_init() calculates a checksum every time it offers a file. We have modification time now but we don't use it for anything.</li>
			<li>Seems like old file descriptors get closed. If nothing is written in a long time, fd might get closed. Do we have any long-term fd?</li>
			<li>File descriptor leaks and limitations: ulimit -n shows we can only have 1024 file descriptors open at once. That's going to limit the potential of group chats. If we get near the limit, we could shed outbound (sendfd) connections? Not a great solution.</li>
			<li>Lots of warnings occur when restarting Tor.</li>
			<li>Cascade deletion of messages and peer specific settings may be untested</li>
			<li>We don't have library protection against running twice. We implement "running" check in GTK. For now, this is ideal. No reason to change this.</li>
			<li>Is --keygen/--key-expiration only for relays? OfflineMasterKey/SigningKeyLifetime</li>
			<li>man atexit. May be useful. Note: Doesn't trigger on signals (ie ctrl + c). Not sure why this would be useful since we handle all exit() calls.</li>
			<li>Add a counter or bunch of counters that increment every time a malloc occurs, so we can know how many leaks we got. (optionally in what areas)</li>
			<li>Public Groups could hypothetically also be shortened in length (pointless), or allow external generation (pointless)</li>
			<li>Consider having UTF8 validator shift forward over any non-utf8 bytes, for use in libevent.c and perhaps message_send (to avoid sql issues), rather than discarding whole messages.</li>
			<li>For GROUP_PEER, .message and .message_len could be double pointer + pointer, respectively. Unsure if viable and how we would re-structure our message struct for that. This can be ignored for now so long as we aren't having bugs.</li>
			<li>Consider ripping out libsodium and replacing it with with openssl (since it is already a tor dependency) or libressl. Be sure that we can do everything in onion_gen.c (ex: crypto_sign_ed25519_pk_to_curve25519)</li>
			<li>Consider moving the message size and protocol behind the .message pointer (so we can avoid copying moving message when signing).</li>
			<ul>
				<li>Main issue is that then freeing messages would require a special torx_free, which is very bad. Not worth it.</li>
			</ul>
			<li>Kill codes have never been tested in groups because deleting individual peers in groups is a complex concept (since they'll just be re-added)</li>
		</ul>
	<!--	<h4>Possibly no longer relevant:</h4>
		<ul>
			<li>Support for 0 length messages was removed at some point. This is an artificial limitation that didn't always exist.</li>
			<li>Tor going idle. "idle" ... "While not bootstrapping". Note: Not "dormant". See #tor logs for clarification.</li>
			<li>broadcast_threaded should ONLY message_send WHEN WE ARE CONNECTED, otherwise it will queue up all our messages and then send them all at once when we get online... totally defeating the purpose of a queue. This is easy to implement for ENUM_OWNER_CTRL (we can just check online status), but harder to implement with GROUP_CTRL.</li>
			<li>When requesting group files (in message_prep currently and select_peer, both), we should request a *random* largest section (+/- 1), rather than the first available one, to help the spread of the file into the network.</li>
			<li>If a peer pauses or cancels, or otherwise ignores file requests, some sections may end up unrequested until restart.</li>
			<li>Test in debugger before investing time: illegal reads could result if we have >10 group files, since everyting occurs on peer[n].file[f] of group_peer_n, which may not be allocated.</li>
			<li>If there is any file transfer corruption caused by repeated pauses and restarts, it is due to races on ].fd_out_</li>
			<li>2024/03/11 Utilizing the return of message_insert(), we could permit the modification of messages ... but only group messages, ???</li>
			<li>Putting no incoming auth doesn't prevent connections. Test this, but based on logs from invalid auth, it seems auth is optional.</li>
			<li>output_cb reported message pos > message_len:</li>
			<ul>
				<li>32 > 0. Protocol: Sticker Request. Likely will corrupt message. Packet len was 40</li>
				<li>494 > 0. Protocol: Sticker data. Likely will corrupt message. Packet len was 498</li>
			</ul>
			<li>Deleting more than 10 messages then sending/receiving a new message results in realloc attempting to shrink the message struct, and then there can be other issues.</li>
			<ul> // TODO do not remove this block
				<li>We should probably resize the struct (down) when we delete message history, or</li>
				<li>We could (should?) use a linked list for our messages (like we do with group messages), instead of an array of struct, to vastly reduce the RAM cost of streaming data</li>
				<ul>
					<li>With enough work, we could eliminate n,i,g,f by using linked lists</li>
					<li>We would pass around abstracted structs for each peer/message/etc.</li>
					<li>For indexing, we use msg_index_iter && msg_index. See group_list usage for example.</li>
					<li>Pointer vs double pointer? How would we handle deletion/free?</li>
					<ul>
						<li>Without double pointers, we would just free everything and remove from linked list.</li>
						<li>Any references would have to be removed, or problems would occur.</li>
					</ul>
				</ul>
			</ul>
		</ul> -->
	<section id="ui">
		<h3>TODO List for Both UIs (Flutter and GTK4):</h3>
		<h4>High Priority / Security Audit:</h4>
		<ul> <!-- Note: GStreamer can be compiled for Android, if absolutely necessary. -->
			<li>peer_onine_cb/peer_offline_cb/call_peer_joining/call_peer_leaving should trigger rebuilds of popovers. In GTK, by re-populating the appropriate list_store. In Flutter, with changeNotifierPopoverList.</li>
			<li>Participating List popover should also be re-built when a peer is speaking (to flash badge), and in GTK when someone clicks "mic/mic_off" "volume_up/volume_off" icons to toggle peer specific setting in Participant List (currently it is static).</li>
			<li>Pete Hegseth function: When a new GROUP_PEER joins, some sort of message needs to be displayed in channel showing who invited them. Perhaps we should generate a non-sendable message type that can be saved into the database and appear as a permanent local notification in the channel.</li>
			<li>Missed call: should also be displayed as a non-sendable message in channel, similar to Pete Hegseth function. Completed calls probably don't need to be noted.</li>
			<li>RAM: Get stickers out of RAM.</li>
			<li>Un-pause option is not available for PM transfers. (May also apply to Flutter?)</li>
			<li>Messages that come in out-of-order in group chats are printed as the come in, instead of in-order, if chat is open. (May also apply to Flutter?)</li>
			<li>When deleting group chat history, only sent public messages disappear immediately. The rest disappear when the chat route is re-opened. (Possibly related to above) (May also apply to Flutter?)</li>
			<li>Global and per-peer settings of "Enable microphone"</li>
			<li>Check destination folder write permissions before allowing its' selection</li>
			<li>String functions in UI should use secure allocators/de-allocators, if possible. (Note: not possible?)</li>
			<li>Analyze audio recordings for metadata? Requires writing samples to disk or analyzing sources https://gstreamer.freedesktop.org/documentation/application-development/advanced/metadata.html?gi-language=c</li>
		</ul>
		<h4>Medium Priority:</h4>
		<ul>
			<li>RAM: Perhaps offload messages as soon as we get to the bottom?</li>
			<li>Streaming audio: Ideas? The biggest issue is playback. In audio.c, we would have to write a new playback function. In flutter, unknown.</li>
			<li>Walkie-talkie mode / Touch to speak: When enabled during a voice call, display Participant List and only two buttons: one small one to leave the mode, and a massive one to touch to speak. Touching simply enables microphone, which is otherwise disabled.</li> <!-- Outdated: Auto-play is an issue because multiple messages could come in at the same time and overlap. Could be resolved with 'stream, disgard' and a queue. Unsure whether to have a unified queue for groups, or a per-peer queue. Unified could experience infinite lag, if everyone is talking at once, which would be intolerable, so a per-peer queue and allowing simultaneous playback from multiple peers may be preferable. This would give a true walkie experience, but messages must be sent *live* rather than once fully recorded.</li> -->
			<li>There could be an UI option to set a debug_file location, and then upon startup have that log pop up (partially as a reminder that it should be disabled).</li>
			<li>Better notifications for calls</li>
			<ul>
				<li>Clicking notifications (both message and calls) should open the proper route (Flutter + GTK)</li>
				<li>Flutter notifications should cancel after replies are sent (attempts made, no success)</li>
				<li>Accept / Decline within the notification (GTK)</li>
				<li>Peer list should rebuild and display something, or flash, to indicate an waiting call (Flutter + GTK)</li>
				<li>Notifications may need to last longer (Flutter + GTK)</li>
			</ul>
			<li>Test and document "Stealth addresses". Facilitated by peer_save(), "Stealth Addresses" functionality is where invalid (non-base32) and excessive (beyond 51 characters) characters are stripped. To utilize, take a 51(?) length TorX-ID, sprinkle invalid characters throughout it as desired, add unlimited length suffix trailing it, and then pass to peer_save. Note: cannot be exactly 56 characters long? Needs review and testing.</li>
			<li>Have a toggle for kill_delete. Delete or Disable options.</li>
			<li>Facilitate msg searching via gtk_list_view_scroll_to in GTK4 and ?? in Flutter.</li>
			<li>message_load_more could take a specific time nstime as argument, or time/nstime AND _MIN/_MAX to designate loading more forwards/backwards from a specific message. These would have to be passed to sql_populate_message. This could facilitate loading of searched messages and then scroll from there. NOTE: This will only *really* save having to load thousands of messages if the user then doesn't scroll afterwards and clicks back or something.</li>
			<li>We need to do sanity checks on sticker/image data or people can be crashed with junk stickers/images. (Send 0 size .gif or bunk data for testing)</li>
			<li>Flash entry box red when no nick is entered for generating (generate_onion) or adding onion (save_peer), or when an invalid onion is passed (bad checksum)</li>
			<li>Consider registering a URI? ie: "torx:" Base64 would be a grup, base32 would be a SING/MULT. is_valid_b32_input( and b64_isvalidchar( in conjunction can determine whether a string is peer/group/trash, for use with 'Search' or invalid input when adding peer.</li>
		</ul>
		<h4>Low Priority:</h4>
		<ul>
			<li>"Tor is running on port ..." could be displayed on settings page or "Tor Port: ..." at the top of Tor Log? (better)</li>
		<!--	<li>Could perhaps have a button to delete the tor_data_directory, though that may rarely be of benefit and would require a restart of tor.</li> -->
			<li>"Peer Group Block" lists could be replaced with "Person Groups(or Diversity_2) No_Accounts" Google SVG icons for more standardized and intuitive appearance</li>
			<li>If a last_message is too long, is there any way we can prevent it from cutting a character in half? We can't simply use multiples of 4 because spaces and newlines.</li>
			<li>Multi-select messages and "forward" / "delete" / "resend" for them</li>
			<li>ENUM_PROTOCOL_UTF8_TEXT_QUOTE could include a suffix of the quoted message time + nstime. Main difficulty in implementation is UI design.</li>
			<li>Multi-Select: Tables should allow multiple selections for deletion. It should show only Delete (or Accept + Reject).</li>
			<li>Implement our fancy new .SVG icons (can wait for GTK4.14) and colorize, replacing .PNG files. Search our code for gtk_symbolic_paintable_snapshot_symbolic, where we have an example implementation ready.</li>
			<li>Tooltips: Use text_tooltip_ prefix. For flutter, https://material.io/components/tooltips alternatively we have used showSnackBar in Flutter and could use it for safety warnings/etc.</li>
			<li>Have a tooltip that shows TorX-IDs, at least on the group's peerlist</li>
			<li>If someone is fast on the censored region toggle while waiting for login, it will save the setting but not take effect until next restart</li>
			<li>Should probably have a "doing checksum" spinner or something for file transfers, so people don't add more than once</li>
			<li>Could have a toggleable option about whether to run as a tor binary as a middle node (this would support the network, but be bandwidth eating)</li>
		</ul>
	<!--	<h4>Possibly no longer relevant:</h4>
		<ul>
		</ul> -->
	<section id="gtk4">
		<h3>TODO List for GTK4 client:</h3>
		<h4>High Priority / Security Audit:</h4>
		<ul>
			<li>transfer_progress_idle can segfault on t_peer[n].t_file[f].progress_bar if messages are deleted. We should be nulling t_peer[n].t_file[f].progress_bar when deleting file messages.</li>
			<li>Clearing group messages only makes the outbound group messages immediately disappear and doesn't effect the GROUP_PEER messages.</li>
			<li>Need to list appropriate GStreamer package as a build dependancy</li>
			<li>t_main.global_pos and ].pos need to be analysed. Whether they are fully working or not is unknown. It's likely that adding messages from pos==0 is breaking every subsequent .pos, which likely needs to be modified (so, if we add 15 messages from 0, every other message with >0 ].pos needs to be +=15. For efficiency, this would be done in the functions that call print_message, not in print_message itself).</li>
			<li>ListView should be a direct child of ScrolledWindow. If it is a child of a box, there may be issues if having >205 widgets (experienced in a test build). There are 3 places where we might face this issue (ctrl+f gtk_list_view_new), but our chat history itself is properly setup.</li>
		</ul>
		<h4>Medium Priority:</h4>
		<ul>
			<li>file_set_path should be used to set .file_path, instead of manually setting it.</li>
			<li>GTK_FACTORY_BUG mitigation has a side effect: messages are not reloaded until application restart, which means that modifying peernicks of group members do not change nicks within loaded messages until restart. Mitigate by re-loading effected messages.</li>
			<li>Bug: Messages that are larger than the chat window cannot be long-pressed properly (so cannot copy, etc). Issue is caused by the popover being spawned at the top of the message rather than the point of long-press.</li>
			<li>While minimized to tray, message scroll doesn't really work. The scroll_func_idle gets called, but to no effect.</li>
			<li>Create .deb file + Debian repo</li>
			<li>Create .rpm file + RedHat repo</li>
			<li>Create .??? file + MacOS brew.sh repo</li> <!-- ??? librewolf is on brew -->
			<li>Windows build:</li>
			<ul>
				<li>Saving torrc results in warnings to override. Should complain to #tor if they persist.</li>
				<li>Need to ship an installer or just zip up the files (if that is sufficient).</li>
				<li>Need a "Microsoft code signing certificate"(?) to be able to distribute without warnings.</li>
				<li>"Microsoft Store" listing should be considered.</li>
				<li>Note for devs: torx-tray.exe may not die when TorX is abruptly killed (ex: ctrl+c in GDB) because TCP connections are not properly closed. Unavoidable without dropping a PID file, but this should only be an issue for devs who are repeatedly building in the same directory of execution (builds might fail on torx-tray.exe because it is running). This issue should not exist for users because multiple instances of torx-tray.exe can run concurrently.</li>
			</ul>
			<li>Images should be clickable (to show larger).</li>
		</ul>
		<h4>Low Priority:</h4>
		<ul>
			<li>Landscape style images, at least in group PM, end up displaying undersized in an oversized message bubble.</li>
			<li>Allow adding multiple stickers at once, from filepicker.</li>
			<li>Rebuild message list after file transfer deletes (or specific message)</li>
			<li>Clicking back while modifying peernick causes loss of changes (only in GTK4)</li>
			<li>Vertical mode: consider putting Send button below the emoji and attach buttons, or simply hide buttons other than Send while typing (like Flutter client).</li>
			<li>Memory leakage: Free memory. Eliminate memory leaks so that it can valgrind 0. g_free, g_object_free(), etc Unsure how to handle sensitive things.</li>
			<li>Review any _swapped( and instead set proper args for given ::signal) (note: if signal can't be found in GTK docs, check gobject docs)</li>
			<li>Have some clang specific compile flags. Could add more. See CMakeLists.txt.</li>
			<li>Fully Mitigated by GTK_FACTORY_BUG=1: g_list_store_insert/splice in GTK4 are horribly inefficient until https://gitlab.gnome.org/GNOME/gtk/-/merge_requests/7420 gets merged</li>
			<li>Partially mitigated by GTK_FACTORY_BUG=1: Loading chats is horribly slow until gtk_list_base_set_anchor_max_widgets stops being passed GTK_LIST_VIEW_MAX_LIST_ITEMS as n_center, because it builds 205 widgets.</li>
			<li>INVERSION_TEST is necessary until https://gitlab.gnome.org/GNOME/gtk/-/issues/4680 gets resolved</li>
			<li>Gnotification can't use gresource icon. We already worked around it by dropping a .png, but we also have a .png for our .desktop file. If we set icon_logo to NULL, the icon registered with DBUS by .desktop will be used.</li>
		</ul>
	<!--	<h4>Possibly no longer relevant:</h4>
		<ul>
			<li>Efficiency:</li>
			<ul>
				<li>When print_message has scroll==0, the IntPair should be cached in an array and later passed to g_list_store_splice when there is a scroll==1. This should prevent thousands of unnecessary calls to message_builder.</li>
				<li>Likewise, when scroll==-1, it should also be cached until reaching min_i.</li>
				<li>This is incorrect. message_builder is not called excessively, it seems? However, doing what is listed here could result in some improvement, just not as significant as stated.</li>
			</ul>
		</ul> -->
	<section id="flutter">
		<h3>TODO List for Flutter client:</h3>
		<h4>High Priority / Security Audit:</h4>
		<ul>
			<li>Outgoing voice messages are momentarily cached on disk: record.start( needs replacing with record.startStream(, but currently the "record" package has bugs</li>
			<li>Values passed to changeNotifier(s) are inconsistent and arbitrary because in most cases we don't use them. We should universally standardize them and utilize them with $changeNotifier.section.$value</li>
			<li>CMakeLists.txt: Depreciate the BUILD_BINARIES argument in favor of checking if they are already built.</li>
			<ul>
				<li>Passing environmental variables to CMake through Flutter seems unreliable at best (may only be working when building re-binaries, with clean directories, at best).</li>
				<li>Resolve issues / causes of unnecessary rebuilds (libevent related issue). Alternatively, BUILD_ALWAYS TRUE or otherwise force clean rebuild of libevent.</li>
				<li>Allow forcing of rebuilds for when deps change? CMake can ideally handle this</li>
			</ul>
			<li>CMakeLists.txt: Ship a release version of Tor instead of building from main (this requires following tor-announce mailing list and manually updating CMakeLists.txt for every stable release)</li>
			<li>File picker caches in /data/user/0/com.torx.chat/cache/file_picker/, causing failure to resume outbound transfers after restarting</li>
			<li>Can we prevent other applications from knowing this application is installed?</li>
			<li>Client attempts to connect to https://firebaselogging.googleapis.com/v0cc/log/batch?format=json_proto3. Need to prevent that and verify that it isn't making other connections. We may need to fork all our dependencies to disable any firebase reference or remote connections.</li>
			<li>Consider having a popup when adding something to clipboard. The clipboard would have a "Clear clipboard" and "Exit" option, along with a warning about other applications being able to steal clipboard contents. In some softwares (ie password managers), after ~45 seconds, it will clear the clipboard.</li>
		</ul>
		<h4>Medium Priority:</h4>
		<ul>
			<li>Need to do more testing with horizontal views. Known issue: Deleting stuff on Home page is impossible in horizontal mode. Other stuff untested.</li>
			<li>Rebuilds are still too frequent; mostly when bringing keyboard up, NOT caused by use of MediaQuery (tested by eliminating all). https://github.com/flutter/flutter/issues/105184</li>
			<li>Crash: Likely related to but NOT caused by android:stopWithTask="false" in AndroidManifest.xml? Read: https://stackoverflow.com/questions/19568315/how-to-handle-running-service-when-app-is-killed-by-swiping-in-android Occurs occassionally when application is in the background, especially when other high-RAM applications are running https://stackoverflow.com/questions/44425584/context-startforegroundservice-did-not-then-call-service-startforeground E/AndroidRuntime(12140): android.app.RemoteServiceException$ForegroundServiceDidNotStartInTimeException: Context.startForegroundService() did not then call Service.startForeground(): ServiceRecord{52682ad u0 com.torx.chat/com.dexterous.flutterlocalnotifications.ForegroundService}</li>
			<li>Crash: Also FlutterLocalNotifications, Unable to start service com.dexterous.flutterlocalnotifications.ForegroundService@52b4439 with null: java.lang.NullPointerException: Attempt to invoke virtual method 'java.io.Serializable android.content.Intent.getSerializableExtra(java.lang.String, java.lang.Class)' on a null object reference</li>
			<li>Isolates: showsUserInterface should be false, but we can't get it to work. Seems like few if any have (seems like they only use it with cancelNotification): https://github.com/search?q=%22showsUserInterface%3A+false%22&type=code with the only exception being here: https://github.com/jenspfahl/EverydayTasks/blob/a85475deae37649ba8ef18978e19270e3ba7ebb6/lib/ui/pages/ScheduledTaskList.dart#L977 Note: If we re-write our notifications (and perhaps callbacks) in native code for better lifecycle management, this issue would be irrelevant.</li>
			<li>Delete temporaryDir/qr.png on program startup and shutdown (or when going to AppLifecycleState.paused?). Zero and delete might be best.</li>
			<li>Message box height: 400 is too tall. Figure out a way to avoid hard coding it.</li>
		</ul>
		<h4>Low Priority:</h4>
		<ul>
			<li>Too long of a nick can overflow a activity bar.</li>
			<li>Consider other default ringtone/beeps, such as https://freesound.org/people/knufds/sounds/633159/</li>
			<li>"Resend" is available in different/less circumstances than in GTK</li>
			<li>Flutter CMakeLists.txt: If jnilibs is populated with files, don't try to copy output binaries into jnilibs because if deleted the build dir and rebuilt a release only, it will be empty.</li>
			<li>Can't change app name on the fly, but can change icon. Could use it to notify user of messages or put alternate icon option (calculator, or something people never use). "The calculator theoretically opens chat but it doesn't work anymore. They said it requires entering a specific calculation," Micay said.</li>
			<li>Should use gallery with photo_view to allow swipping back/forward to see other images in PhotoView.</li>
			<li>autoRunOnBoot: true (foreground task) + fix BootBroadcastReceiver.kt, then have a toggle in settings page for both.</li>
			<li>Consider requesting battery optimization exemption</li>
			<li>Calling peer_accept() while actively modifying peernick results in modifications being lost</li>
			<li>Lifecycle: Notifications may have to handled by callbacks written in Java/Kotlin to prevent their disposal during lifecycle events. Singleton was attempted, but didn't help.</li>
			<li>Lifecycle: RestorationScopeId seems to not be saving our route. Unsure if it saves anything. If we can get it to work, we can use restorationId on TextField and ScrollView (note: security implications of saving to disk in cleartext)</li>
			<li>Lifecycle needs a full audit, including use of restorationScopeId, initialization_functions(), resumptionTasks()</li>
			<li>Prevent un-encrypted backups of android data? Most chat apps do this but I'm on the fence because our data is encrypted, and we do want to support history migration. GrapheneOS project has some info that suggests we can block only unencrypted backups.</li>
			<li>Comment out any unused color and language strings. Ensure that we don't have any strings not in our languages file.</li>
			<li>AnimatedBuilder should replace most or all remaining of our setState calls, for efficiency. There are few left.</li>
			<li>We lose TorX log and Tor log contents every time we .detach, so we might consider to store it in a library defined C pointer so it stays in RAM. We would just need to create the pointer in lib and the remaining work is done in flutter. However, this is kind of contrary to the direction we are going, which is to be able to minimize RAM usage in Android.</li>
		</ul>
	<!--	<h4>Possibly no longer relevant:</h4>
		<ul>
		</ul> -->
</body>
</html>
